<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <title>GeoDefense: Hyper Grid</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; touch-action: none; }
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }

        /* UI Layer */
        #ui-layer { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD */
        .hud-bar {
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), rgba(0,0,0,0));
            padding: 10px 15px; display: flex; justify-content: space-between; align-items: flex-start;
            font-weight: bold; font-size: 16px; text-shadow: 0 0 5px currentColor; pointer-events: auto;
        }
        .stat-col { display: flex; flex-direction: column; gap: 5px; }
        .stat-row { display: flex; gap: 15px; }
        .stat-hp { color: #f33; } .stat-cash { color: #ff3; } .stat-wave { color: #3ff; } .stat-score { color: #fff; }

        /* Pause Button */
        #btn-pause {
            width: 40px; height: 40px; border: 2px solid #fff; border-radius: 50%;
            background: rgba(0,0,0,0.5); color: #fff; font-size: 18px; line-height: 36px;
            text-align: center; cursor: pointer; pointer-events: auto;
        }

        /* Controls */
        .controls-bar {
            background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,0,0));
            padding: 10px; padding-bottom: 30px; display: flex; justify-content: center; gap: 8px;
            pointer-events: auto;
        }
        .tower-drag {
            width: 55px; height: 60px; border-radius: 6px; border: 1px solid #444; background: #0a0a0a;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; transition: transform 0.1s;
        }
        .tower-drag:active { transform: scale(1.1); border-color: #fff; }
        .t-icon { width: 24px; height: 24px; margin-bottom: 4px; pointer-events: none; }
        .t-cost { font-size: 10px; color: #aaa; pointer-events: none; }
        
        /* Tower Styles for UI */
        .c-green { color: #0f0; border-color: #050; } .c-green .t-icon { background: #0f0; clip-path: polygon(20% 0, 80% 0, 100% 100%, 0 100%); }
        .c-red { color: #f00; border-color: #500; } .c-red .t-icon { background: #f00; clip-path: polygon(50% 0, 100% 100%, 0 100%); }
        .c-blue { color: #0af; border-color: #005; } .c-blue .t-icon { background: #0af; clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%); }
        .c-yellow { color: #ff0; border-color: #550; } .c-yellow .t-icon { background: #ff0; border-radius: 50%; border: 3px solid #ff0; background: transparent; }
        .c-purple { color: #d0f; border-color: #505; } .c-purple .t-icon { background: #d0f; clip-path: polygon(10% 0, 90% 0, 90% 100%, 10% 100%); }

        /* Menus */
        #upg-menu {
            position: absolute; display: none; pointer-events: auto; z-index: 100;
            background: rgba(10,10,10,0.9); border: 1px solid #fff; border-radius: 6px;
            padding: 8px; text-align: center; box-shadow: 0 0 15px rgba(255,255,255,0.2);
            transform: translate(-50%, -120%); min-width: 130px;
        }
        #upg-menu::after { content:''; position: absolute; bottom:-6px; left:50%; margin-left:-6px; border-width:6px 6px 0; border-style:solid; border-color:#fff transparent; }
        .menu-header { font-size:12px; color:#aaa; margin-bottom:6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .menu-btn { display: block; width: 100%; padding: 8px; margin: 4px 0; background: #222; color: #fff; border: 1px solid #444; font: inherit; font-size: 11px; cursor: pointer; }
        .btn-upg { color: #afa; border-color: #252; } .btn-sell { color: #f55; border-color: #522; }

        #btn-wave {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            padding: 8px 16px; border: 1px solid #3ff; color: #3ff; background: rgba(0,20,20,0.8);
            border-radius: 20px; cursor: pointer; pointer-events: auto; animation: pulse 1s infinite; display: none;
            font-size: 14px; z-index: 50;
        }
        @keyframes pulse { 0% {box-shadow:0 0 5px #3ff;} 50%{box-shadow:0 0 15px #3ff;} 100%{box-shadow:0 0 5px #3ff;} }

        #overlay { 
            position: fixed; top:0;left:0;width:100%;height:100%; background:rgba(0,0,0,0.85); 
            color:#0f0; display:flex; flex-direction:column; align-items:center; justify-content:center; 
            font-size:24px; z-index:999; text-shadow: 0 0 10px #0f0; text-align: center;
        }
        .blink { animation: blinker 1s linear infinite; margin-top: 20px; font-size: 16px; color: #fff;}
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="ui-layer">
    <div class="hud-bar">
        <div class="stat-col">
            <div class="stat-row"><span class="stat-hp">HP <span id="ui-hp">20</span></span> <span class="stat-cash">$<span id="ui-cash">120</span></span></div>
            <div class="stat-row"><span class="stat-wave">WAVE <span id="ui-wave">1</span></span> <span class="stat-score">SC <span id="ui-score">0</span></span></div>
        </div>
        <div id="btn-pause" onclick="togglePause()">||</div>
    </div>
    
    <div id="btn-wave" onclick="forceNextWave()">NEXT WAVE (<span id="ui-timer">0</span>)</div>

    <div id="upg-menu">
        <div class="menu-header" id="m-info">TOWER LV1</div>
        <button class="menu-btn btn-upg" id="m-upg">UPGRADE</button>
        <button class="menu-btn btn-sell" id="m-sell">SELL</button>
    </div>

    <div class="controls-bar">
        <div class="tower-drag c-green" data-type="green"><div class="t-icon"></div><span class="t-cost">$15</span></div>
        <div class="tower-drag c-red" data-type="red"><div class="t-icon"></div><span class="t-cost">$40</span></div>
        <div class="tower-drag c-blue" data-type="blue"><div class="t-icon"></div><span class="t-cost">$80</span></div>
        <div class="tower-drag c-yellow" data-type="yellow"><div class="t-icon"></div><span class="t-cost">$60</span></div>
        <div class="tower-drag c-purple" data-type="purple"><div class="t-icon"></div><span class="t-cost">$120</span></div>
    </div>
</div>

<div id="overlay" onclick="startGame()">
    <div>GEODEFENSE: HYPER GRID</div>
    <div style="font-size:14px; color:#aaa; margin-top:10px">Build maze using towers.<br>Avoid grey obstacles.</div>
    <div class="blink">TAP TO START</div>
</div>

<script>
// --- Audio System ---
let actx;
function initAudio() { if(!actx) actx = new (window.AudioContext || window.webkitAudioContext)(); }
function playSound(type) {
    if(!actx) return;
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.connect(gain); gain.connect(actx.destination);
    let t = actx.currentTime;

    if(type==='shoot') {
        osc.frequency.setValueAtTime(600, t); osc.frequency.exponentialRampToValueAtTime(100, t+0.1);
        gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
        osc.start(t); osc.stop(t+0.1);
    } 
    else if(type==='hit') {
        osc.type = 'triangle'; osc.frequency.setValueAtTime(150, t); 
        gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
        osc.start(t); osc.stop(t+0.1);
    }
    else if(type==='boom') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.3);
        gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.3);
        osc.start(t); osc.stop(t+0.3);
    }
    else if(type==='place') {
        osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t+0.1);
        gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.15);
        osc.start(t); osc.stop(t+0.15);
    }
}

// --- Game Data ---
const TOWER_DATA = {
    green:  { name: "BLASTER", cost: 15, range: 100, dmg: 8, rate: 12, color: '#0f0', type:'bolt' },
    red:    { name: "MISSILE", cost: 40, range: 160, dmg: 40, rate: 70, color: '#f00', type:'missile', splash: 50 },
    blue:   { name: "LASER",   cost: 80, range: 999, dmg: 0.8,rate: 0,  color: '#0af', type:'laser' }, // Infinite range logic
    yellow: { name: "SHOCK",   cost: 60, range: 90,  dmg: 4,  rate: 45, color: '#ff0', type:'shock' },
    purple: { name: "SNIPER",  cost: 120,range: 350, dmg: 150,rate: 110,color: '#d0f', type:'sniper' }
};

let G = {
    w:0, h:0, hexR:0, active:false, paused:false,
    hp:20, cash:120, wave:1, score:0,
    grid:[], path:[], towers:[], enemies:[], projs:[], parts:[], shocks:[],
    start:null, end:null, selected:null,
    dragType:null, dragPos:{x:0,y:0},
    nextWaveTime:0, spawning:false, spawnQ:0, frame:0
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// --- Core Functions ---
function startGame() {
    initAudio();
    document.getElementById('overlay').style.display='none';
    G.active=true;
    resize();
    setTimer(5);
    loop();
}

function togglePause() {
    G.paused = !G.paused;
    document.getElementById('btn-pause').innerText = G.paused ? "â–º" : "||";
}

function resize() {
    G.w = window.innerWidth; G.h = window.innerHeight;
    canvas.width = G.w; canvas.height = G.h;
    G.hexR = Math.max(14, Math.floor(G.w / 32)); 
    initGrid();
}

function initGrid() {
    // Retry loop to ensure a valid map is generated
    let validMap = false;
    while(!validMap) {
        G.grid = [];
        const w = G.hexR * Math.sqrt(3);
        const h = G.hexR * 2;
        const vDist = h * 0.75;
        const cols = Math.floor(G.w / w);
        const rows = Math.floor(G.h / vDist);
        const offX = (G.w - cols * w)/2 + w/2;
        const offY = (G.h - rows * vDist)/2 + h/2;

        for(let r=0; r<rows; r++) {
            for(let q=0; q<cols; q++) {
                let cx = offX + q * w + (r%2 ? w/2 : 0);
                let cy = offY + r * vDist;
                if(cy < 70 || cy > G.h - 110) continue; // UI Margin
                
                // Random Obstacles (10% chance)
                let isObstacle = Math.random() < 0.12;
                G.grid.push({q, r, x:cx, y:cy, occ:false, obstacle:isObstacle, id: r*1000+q});
            }
        }
        
        G.start = G.grid[0]; G.start.obstacle = false;
        G.end = G.grid[G.grid.length-1]; G.end.obstacle = false;
        
        // Clear neighbors of start/end
        getNeighbors(G.start).forEach(n=>n.obstacle=false);
        getNeighbors(G.end).forEach(n=>n.obstacle=false);

        // Apply obstacles
        G.grid.forEach(c => { if(c.obstacle) c.occ = true; });

        if(calcPath()) validMap = true;
    }
}

// --- Pathfinding & A* ---
function calcPath(tempBlock = null) {
    if(tempBlock) tempBlock.occ = true;
    let open=[G.start], cameFrom=new Map(), gScore=new Map();
    gScore.set(G.start, 0);
    let found = false;

    while(open.length > 0) {
        open.sort((a,b) => (gScore.get(a) + dist(a,G.end)) - (gScore.get(b) + dist(b,G.end)));
        let cur = open.shift();
        if(cur === G.end) { found = true; break; }
        
        for(let n of getNeighbors(cur)) {
            if(n.occ) continue;
            let g = gScore.get(cur) + 1;
            if(g < (gScore.get(n)||Infinity)) {
                cameFrom.set(n, cur); gScore.set(n, g);
                if(!open.includes(n)) open.push(n);
            }
        }
    }
    if(tempBlock) tempBlock.occ = false;
    
    if(!found) return null;
    let path = [], curr = G.end;
    while(curr !== G.start) { path.push(curr); curr = cameFrom.get(curr); }
    path.push(G.start);
    return G.path = path.reverse();
}
function getNeighbors(c) { return G.grid.filter(n => dist(c,n) < G.hexR*2.1 && n!==c); }

// --- Main Loop ---
function loop() {
    requestAnimationFrame(loop);
    if(!G.active || G.paused) return;
    G.frame++;
    
    // Wave Logic
    if(G.spawning) {
        if(G.spawnQ > 0 && G.frame % 35 === 0) {
            spawnEnemy(); G.spawnQ--;
            if(G.spawnQ <= 0) G.spawning = false;
        }
    } else if (G.enemies.length === 0) {
        if(G.nextWaveTime === 0) setTimer(10);
        else if (Date.now() > G.nextWaveTime) startWave();
    }
    
    // UI Timer
    let tSpan = document.getElementById('ui-timer');
    if(G.nextWaveTime > 0 && !G.spawning && G.enemies.length === 0) {
        document.getElementById('btn-wave').style.display='block';
        tSpan.innerText = Math.ceil((G.nextWaveTime - Date.now())/1000);
    } else document.getElementById('btn-wave').style.display='none';

    updateEntities();
    draw();
}

function updateEntities() {
    // Towers
    G.towers.forEach(t => {
        if(t.cd>0) t.cd--;
        
        // Laser Logic (Raycast)
        if(t.type === 'laser') {
            t.target = null; // Reset for visual
            let bestDist = Infinity;
            
            // Find closest enemy to rotate towards
            G.enemies.forEach(e => {
                let d = dist(t,e);
                if(d < t.range && d < bestDist) { bestDist=d; t.target=e; }
            });

            if(t.target) {
                t.angle = Math.atan2(t.target.y - t.y, t.target.x - t.x);
                // Line Collision Check for infinite pierce
                let ex = t.x + Math.cos(t.angle)*2000;
                let ey = t.y + Math.sin(t.angle)*2000;
                
                G.enemies.forEach(e => {
                    if(distToSegment({x:t.x,y:t.y}, {x:ex,y:ey}, e) < (e.size || 10)) {
                        e.hp -= t.dmg * (1+t.lvl*0.5);
                        if(G.frame%5===0) fx(e.x,e.y,t.color,1);
                    }
                });
            }
        } 
        // Standard Projectile Logic
        else {
            if(!t.target || t.target.hp<=0 || dist(t,t.target)>t.range) {
                t.target = G.enemies.find(e=>dist(t,e)<=t.range);
            }
            if(t.target) {
                t.angle = Math.atan2(t.target.y-t.y, t.target.x-t.x);
                if(t.cd<=0) {
                    let dmg = t.dmg * Math.pow(1.4, t.lvl-1);
                    G.projs.push({
                        x:t.x, y:t.y, vx:Math.cos(t.angle), vy:Math.sin(t.angle),
                        spd:10, dmg:dmg, color:t.color, type:t.type, splash:t.splash||0, tar:t.target, life:80
                    });
                    t.cd = t.rate / (1+(t.lvl-1)*0.15);
                    playSound('shoot');
                }
            }
        }
    });

    // Projectiles
    for(let i=G.projs.length-1; i>=0; i--) {
        let p = G.projs[i];
        p.life--;
        if(p.type==='missile' && p.tar && p.tar.hp>0) {
            let ta = Math.atan2(p.tar.y-p.y, p.tar.x-p.x);
            p.vx = p.vx*0.92 + Math.cos(ta)*0.08; p.vy = p.vy*0.92 + Math.sin(ta)*0.08;
        }
        
        // Movement
        p.x+=p.vx*p.spd; p.y+=p.vy*p.spd;
        if(p.type==='frag') p.spd *= 0.9; // Fragments slow down

        let hit = G.enemies.find(e => dist(p,e) < (p.type==='missile'?20:12));
        
        if(hit || p.life<=0) {
            if(hit || (p.type==='missile' && p.life<=0)) { // Missiles explode on timeout too
                if(p.type==='missile') {
                    playSound('boom');
                    fxExplode(p.x,p.y,p.color,12);
                    G.shocks.push({x:p.x, y:p.y, r:1, maxR:60, color:p.color, alpha:1});
                    
                    // Area Damage
                    G.enemies.forEach(e => {
                        if(dist(p,e) < p.splash) e.hp -= p.dmg;
                    });

                    // Shrapnel (Fragments)
                    for(let k=0; k<4; k++) {
                        let a = Math.random()*6.28;
                        G.projs.push({
                            x:p.x, y:p.y, vx:Math.cos(a), vy:Math.sin(a),
                            spd:6, dmg:p.dmg*0.3, color:'#fa0', type:'frag', life:20
                        });
                    }
                } 
                else if(p.type==='shock') {
                    hit.hp -= p.dmg;
                    hit.slow = 100 + (p.dmg*5);
                    G.shocks.push({x:hit.x, y:hit.y, r:1, maxR:30, color:'#ff0', alpha:1});
                }
                else {
                    hit.hp -= p.dmg;
                    fx(p.x,p.y,p.color,3);
                    playSound('hit');
                }
            }
            if(hit || p.life<=0) G.projs.splice(i,1);
        }
    }

    // Shockwaves
    for(let i=G.shocks.length-1; i>=0; i--) {
        let s = G.shocks[i];
        s.r += 2; s.alpha -= 0.05;
        if(s.alpha <= 0) G.shocks.splice(i,1);
    }

    // Enemies
    for(let i=G.enemies.length-1; i>=0; i--) {
        let e = G.enemies[i];
        if(e.hp<=0) {
            G.cash += e.val; G.score += e.val*10;
            fxExplode(e.x,e.y,e.color,20);
            fxHalo(e.x,e.y,e.color); // Death Halo
            updateUI();
            G.enemies.splice(i,1);
            continue;
        }
        
        // Move with offset wiggle
        let target = G.path[e.pi];
        if(target) {
            // Apply path diversity offset
            let tx = target.x + e.ox; 
            let ty = target.y + e.oy;
            
            let moveSpd = e.spd * (e.slow>0 ? 0.4 : 1);
            if(e.slow>0) e.slow--;

            let dx = tx - e.x, dy = ty - e.y;
            let d = Math.hypot(dx,dy);
            
            if(d < moveSpd) {
                e.pi++;
            } else {
                e.x += (dx/d)*moveSpd; e.y += (dy/d)*moveSpd;
                e.angle = Math.atan2(dy, dx);
            }
        } else {
            G.hp--; fxExplode(e.x,e.y,'#f00',20); updateUI();
            G.enemies.splice(i,1);
            if(G.hp<=0) { G.active=false; alert("GAME OVER! Score: "+G.score); location.reload(); }
        }
    }

    // Particles
    for(let i=G.parts.length-1; i>=0; i--) {
        let p = G.parts[i];
        if(p.type === 'halo') {
            p.r += 2; p.life -= 0.04;
        } else {
            p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
        }
        if(p.life<=0) G.parts.splice(i,1);
    }
}

// --- Wave & Enemy Gen ---
function setTimer(s) { G.nextWaveTime = Date.now() + s*1000; }
function forceNextWave() {
    if(G.nextWaveTime > Date.now()) G.score += Math.ceil((G.nextWaveTime - Date.now())/1000)*50;
    startWave();
}
function startWave() {
    G.wave++; G.spawnQ = 6 + Math.floor(G.wave*1.5); G.spawning=true; G.nextWaveTime=0; updateUI();
}
function spawnEnemy() {
    let hpMult = Math.pow(1.25, G.wave);
    let baseHp = 25 * hpMult;
    let shape = 'circle';
    let spd = 1.2 + (G.wave*0.05);
    
    // Enemy Variety based on Wave
    if(G.wave % 5 === 0) shape = 'pentagon'; // Boss
    else if(G.wave > 6 && Math.random()>0.7) shape = 'square'; // Tank
    else if(G.wave > 3 && Math.random()>0.7) shape = 'triangle'; // Fast

    let e = {
        x:G.start.x, y:G.start.y, pi:0, slow:0, hp:baseHp, max:baseHp, spd:spd,
        val: 5 + Math.floor(G.wave/2), shape: shape,
        color: `hsl(${(G.wave*25)%360}, 100%, 60%)`,
        angle: 0,
        ox: (Math.random()-0.5) * (G.hexR*0.8), // Path Offset
        oy: (Math.random()-0.5) * (G.hexR*0.8)
    };

    if(shape==='triangle') { e.spd *= 1.4; e.hp *= 0.6; }
    if(shape==='square') { e.spd *= 0.7; e.hp *= 2.5; e.size=12; }
    if(shape==='pentagon') { e.spd *= 0.5; e.hp *= 8; e.size=15; e.val*=5; }

    G.enemies.push(e);
}

// --- Draw System ---
function draw() {
    ctx.fillStyle = '#050505'; ctx.fillRect(0,0,G.w,G.h);
    
    // Grid
    ctx.lineWidth = 1; 
    G.grid.forEach(c => {
        if(c.obstacle) {
            ctx.fillStyle = '#1a1a1a'; ctx.strokeStyle='#333';
            ctx.beginPath(); hexPath(c.x,c.y,G.hexR-2); ctx.fill(); ctx.stroke();
        } else if(!c.occ) {
            ctx.strokeStyle = '#222';
            ctx.beginPath(); hexPath(c.x,c.y,G.hexR-1); ctx.stroke();
        }
    });

    // Start/End
    drawHexSolid(G.start.x, G.start.y, G.hexR, '#0f0', 0.2);
    drawHexSolid(G.end.x, G.end.y, G.hexR, '#f00', 0.2);

    ctx.globalCompositeOperation = 'lighter';

    // Towers (6 Levels)
    G.towers.forEach(t => {
        // Base
        drawHexSolid(t.x, t.y, G.hexR, t.color, 0.1 + (t.lvl*0.05));
        ctx.strokeStyle = t.color; ctx.shadowColor = t.color; ctx.shadowBlur = 10;
        
        ctx.save(); ctx.translate(t.x,t.y);
        
        // Level Indicators (Outer Rings)
        if(t.lvl > 1) { ctx.beginPath(); ctx.arc(0,0,G.hexR*0.6,0,6.28); ctx.stroke(); }
        if(t.lvl > 3) { ctx.beginPath(); ctx.arc(0,0,G.hexR*0.8,0,6.28); ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]); }
        if(t.lvl === 6) { ctx.beginPath(); ctx.arc(0,0,G.hexR*0.95,0,6.28); ctx.lineWidth=2; ctx.stroke(); ctx.lineWidth=1; }

        ctx.rotate(t.angle);

        // Tower Shapes based on Type & Level
        ctx.beginPath();
        if(t.type === 'bolt') {
            ctx.rect(-5,-5,10,10); 
            ctx.moveTo(5,0); ctx.lineTo(15+(t.lvl*2),0); // Barrel lengthens
            if(t.lvl>=3) { ctx.moveTo(5,-3); ctx.lineTo(12,-3); ctx.moveTo(5,3); ctx.lineTo(12,3); }
            if(t.lvl>=5) { ctx.rect(-8,-8,16,16); ctx.moveTo(0,0); ctx.arc(0,0,4,0,6.28); }
        } else if (t.type === 'missile') {
            ctx.moveTo(-5,-5); ctx.lineTo(12,0); ctx.lineTo(-5,5); 
            if(t.lvl>=3) { ctx.moveTo(-5,-8); ctx.lineTo(8,-3); ctx.lineTo(-5,-2); ctx.moveTo(-5,8); ctx.lineTo(8,3); ctx.lineTo(-5,2); }
            if(t.lvl>=5) { ctx.rect(-6,-6,6,12); ctx.stroke(); } // Launcher box
        } else if (t.type === 'laser') {
            ctx.arc(0,0,6,0,6.28);
            if(t.lvl>=3) { ctx.moveTo(0,-8); ctx.lineTo(0,8); ctx.moveTo(-8,0); ctx.lineTo(8,0); }
            if(t.lvl>=5) { ctx.rotate(G.frame*0.1); ctx.rect(-7,-7,14,14); }
        } else if (t.type === 'shock') {
            ctx.arc(0,0,5,0,6.28); ctx.strokeRect(-7,-7,14,14);
            if(t.lvl>=3) { ctx.rotate(Math.PI/4); ctx.strokeRect(-9,-9,18,18); }
            if(t.lvl>=5) { ctx.beginPath(); ctx.arc(0,0,12,0,6.28); ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]); }
        } else if (t.type === 'sniper') {
            ctx.rect(-4,-4,8,8); ctx.moveTo(4,0); ctx.lineTo(20+(t.lvl*3),0);
            if(t.lvl>=3) ctx.arc(0,0,10,0,3.14);
            if(t.lvl>=5) { ctx.moveTo(25,0); ctx.lineTo(25,-5); ctx.lineTo(30,0); } // Sight
        }
        ctx.stroke();

        // Laser Beam Drawing
        if(t.type==='laser' && t.target) {
            ctx.restore(); ctx.save(); // Break transform
            ctx.shadowBlur=15; ctx.lineWidth=2+(t.lvl*0.5); ctx.strokeStyle=t.color;
            ctx.beginPath(); ctx.moveTo(t.x,t.y); 
            ctx.lineTo(t.x+Math.cos(t.angle)*2000, t.y+Math.sin(t.angle)*2000);
            ctx.stroke(); ctx.lineWidth=1;
            ctx.restore(); ctx.save(); // Dummy save
        }
        ctx.restore();
    });

    // Enemies
    G.enemies.forEach(e => {
        ctx.fillStyle = e.color; ctx.shadowColor = e.color; ctx.shadowBlur = 10;
        ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
        
        ctx.beginPath();
        let s = e.size || 8;
        if(e.shape === 'circle') ctx.arc(0,0,s,0,6.28);
        else if(e.shape === 'triangle') { ctx.moveTo(s,0); ctx.lineTo(-s, s); ctx.lineTo(-s, -s); }
        else if(e.shape === 'square') { ctx.rect(-s,-s, s*2, s*2); }
        else if(e.shape === 'pentagon') { for(let i=0;i<5;i++) ctx.lineTo(s*Math.cos(i*1.25), s*Math.sin(i*1.25)); }
        ctx.fill();

        // HP Bar
        ctx.rotate(-e.angle);
        ctx.fillStyle='#444'; ctx.fillRect(-10, -15, 20, 3);
        ctx.fillStyle='#0f0'; ctx.fillRect(-10, -15, 20*(e.hp/e.max), 3);
        ctx.restore();
    });

    // Projectiles
    G.projs.forEach(p => {
        ctx.fillStyle=p.color; ctx.shadowColor=p.color; ctx.shadowBlur=6;
        ctx.beginPath(); ctx.arc(p.x,p.y, p.type==='frag'?2:3, 0, 6.28); ctx.fill();
    });

    // Shockwaves
    G.shocks.forEach(s => {
        ctx.strokeStyle=s.color; ctx.globalAlpha=s.alpha; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,6.28); ctx.stroke();
        ctx.globalAlpha=1;
    });

    // Particles
    G.parts.forEach(p => {
        ctx.globalAlpha = p.life; 
        if(p.type==='halo') {
            ctx.strokeStyle = p.color; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,6.28); ctx.stroke();
        } else {
            ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,2,2);
        }
        ctx.globalAlpha=1;
    });

    // Drag Overlay
    if(G.dragType) {
        let hex = pixelToHex(G.dragPos.x, G.dragPos.y);
        let data = TOWER_DATA[G.dragType];
        ctx.strokeStyle = data.color; ctx.setLineDash([4,4]);
        ctx.beginPath(); ctx.arc(G.dragPos.x, G.dragPos.y, data.range, 0, 6.28); ctx.stroke();
        ctx.setLineDash([]);
        if(hex) drawHexSolid(hex.x, hex.y, G.hexR, data.color, 0.5);
    }
    
    // Select Overlay
    if(G.selected) {
        ctx.strokeStyle='#fff'; ctx.setLineDash([5,5]);
        ctx.beginPath(); ctx.arc(G.selected.x, G.selected.y, G.selected.range, 0, 6.28); ctx.stroke();
        ctx.setLineDash([]);
    }

    ctx.globalCompositeOperation = 'source-over'; ctx.shadowBlur=0;
}

// --- Utils ---
function hexPath(x,y,r) {
    for(let i=0; i<6; i++) {
        let a = Math.PI/3 * i;
        i===0 ? ctx.moveTo(x+r*Math.cos(a), y+r*Math.sin(a)) : ctx.lineTo(x+r*Math.cos(a), y+r*Math.sin(a));
    }
    ctx.closePath();
}
function drawHexSolid(x,y,r,c,a=1) {
    ctx.fillStyle = c; ctx.globalAlpha = a;
    ctx.beginPath(); hexPath(x,y,r-1); ctx.fill(); ctx.globalAlpha = 1;
}
function pixelToHex(x, y) {
    let minD = Infinity, closest = null;
    for(let c of G.grid) {
        let d = Math.hypot(c.x-x, c.y-y);
        if(d < minD) { minD = d; closest = c; }
    }
    return (minD < G.hexR * 1.5) ? closest : null;
}
function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
// Shortest distance from point P to line segment AB
function distToSegment(A, B, P) {
    const l2 = (A.x-B.x)**2 + (A.y-B.y)**2;
    if(l2==0) return dist(P,A);
    let t = ((P.x-A.x)*(B.x-A.x) + (P.y-A.y)*(B.y-A.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return dist(P, { x: A.x + t*(B.x-A.x), y: A.y + t*(B.y-A.y) });
}

// --- FX ---
function fx(x,y,c,n) { for(let i=0;i<n;i++) G.parts.push({x,y,vx:(Math.random()-.5)*4,vy:(Math.random()-.5)*4,life:1,color:c}); }
function fxExplode(x,y,c,n) { fx(x,y,c,n*3); }
function fxHalo(x,y,c) { G.parts.push({x,y,r:5,life:1,color:c,type:'halo'}); }

// --- Input Handling ---
function startDrag(e, type) { e.preventDefault(); if(G.selected) closeMenu(); G.dragType = type; updateDragPos(e); }
function moveDrag(e) { if(G.dragType) { e.preventDefault(); updateDragPos(e); } }
function updateDragPos(e) { let t = e.touches?e.touches[0]:e; G.dragPos.x = t.clientX; G.dragPos.y = t.clientY - 40; }
function endDrag(e) {
    e.preventDefault(); if(!G.dragType) return;
    let hex = pixelToHex(G.dragPos.x, G.dragPos.y);
    let data = TOWER_DATA[G.dragType];
    
    if(hex && !hex.occ && !hex.obstacle && hex!==G.start && hex!==G.end) {
        if(G.cash >= data.cost) {
            if(calcPath(hex)) {
                G.cash -= data.cost; hex.occ = true;
                G.towers.push({q:hex.q, r:hex.r, x:hex.x, y:hex.y, ...data, cd:0, lvl:1, angle:0});
                playSound('place'); fxExplode(hex.x, hex.y, '#fff', 8); updateUI();
            } else { playSound('hit'); fxExplode(hex.x,hex.y,'#f00',5); }
        } else playSound('hit');
    }
    G.dragType = null;
}
function handleClick(e) {
    if(G.dragType) return;
    let hex = pixelToHex(e.clientX, e.clientY);
    if(hex && hex.occ && !hex.obstacle) {
        let t = G.towers.find(to => to.q === hex.q && to.r === hex.r);
        if(t) selectTower(t);
    } else closeMenu();
}
function selectTower(t) {
    G.selected = t;
    const m = document.getElementById('upg-menu');
    m.style.display = 'block'; m.style.left = t.x+'px'; m.style.top = (t.y-20)+'px';
    
    let isMax = t.lvl >= 6;
    let cost = Math.floor(t.cost * t.lvl * 0.7);
    let sell = Math.floor(t.cost * 0.5 * t.lvl);
    
    document.getElementById('m-info').innerText = `${t.name} LVL ${t.lvl}`;
    let btnUp = document.getElementById('m-upg');
    btnUp.innerText = isMax ? "MAX" : `UPGRADE $${cost}`;
    btnUp.style.opacity = isMax ? 0.5 : 1;
    document.getElementById('m-sell').innerText = `SELL $${sell}`;
    
    btnUp.onclick = () => {
        if(!isMax && G.cash >= cost) {
            G.cash -= cost; t.lvl++; t.dmg *= 1.35;
            playSound('place'); fxHalo(t.x,t.y,t.color); updateUI(); selectTower(t);
        } else playSound('hit');
    };
    document.getElementById('m-sell').onclick = () => {
        G.cash += sell;
        G.grid.find(g=>g.q===t.q && g.r===t.r).occ = false;
        G.towers = G.towers.filter(to => to !== t);
        calcPath(); updateUI(); closeMenu();
    };
}
function closeMenu() { G.selected=null; document.getElementById('upg-menu').style.display='none'; }
function updateUI() {
    document.getElementById('ui-hp').innerText = G.hp;
    document.getElementById('ui-cash').innerText = Math.floor(G.cash);
    document.getElementById('ui-wave').innerText = G.wave;
    document.getElementById('ui-score').innerText = G.score;
}

// Events
window.addEventListener('resize', resize);
const drags = document.querySelectorAll('.tower-drag');
drags.forEach(d => {
    d.addEventListener('touchstart', e => startDrag(e, d.dataset.type), {passive:false});
    d.addEventListener('mousedown', e => startDrag(e, d.dataset.type));
});
window.addEventListener('touchmove', moveDrag, {passive:false});
window.addEventListener('mousemove', moveDrag);
window.addEventListener('touchend', endDrag);
window.addEventListener('mouseup', endDrag);
canvas.addEventListener('click', handleClick);
</script>
</body>
</html>
