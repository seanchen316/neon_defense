<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#111111">
    <title>GeoDefense: Final Fix</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; touch-action: none; }
        body { 
            margin: 0; background: #111; overflow: hidden; font-family: 'Courier New', monospace; 
            display: flex; flex-direction: column; height: 100vh; width: 100vw;
        }

        /* Top HUD */
        #top-bar {
            height: 40px; background: #080808; border-bottom: 1px solid #333;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 15px; flex-shrink: 0; z-index: 10;
        }
        .stat-group { display: flex; gap: 15px; font-weight: bold; font-size: 14px; text-shadow: 0 0 5px currentColor; }
        .stat-cash { color: #ff3; } .stat-wave { color: #3ff; } .stat-score { color: #fff; }
        
        .top-btn {
            border: 1px solid #555; color: #888; font-size: 11px; padding: 6px 12px; 
            border-radius: 4px; cursor: pointer; background: #222; font-weight: bold;
        }
        .top-btn.active { color: #0f0; border-color: #0f0; background: #002200; }

        /* Game Area */
        #game-container { flex-grow: 1; position: relative; overflow: hidden; background: #050505; }
        canvas { display: block; width: 100%; height: 100%; }

        /* Bottom Controls */
        #bottom-bar {
            height: 90px; background: #080808; border-top: 1px solid #333;
            display: flex; justify-content: center; align-items: center; gap: 8px;
            padding: 0 10px; flex-shrink: 0; z-index: 10;
        }

        /* Tower Card */
        .tower-card {
            width: 50px; height: 65px; border-radius: 4px; 
            border: 1px solid #333; background: #151515;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            position: relative; transition: transform 0.1s; cursor: pointer;
        }
        .tower-card:active { transform: scale(1.1); border-color: #fff; background: #222; }
        .t-canvas { position: absolute; top: 5px; left: 0; width: 48px; height: 40px; pointer-events: none; }
        .t-cost { font-size: 10px; color: #888; margin-bottom: 4px; pointer-events: none; font-weight: bold; }
        
        /* Pause Button */
        #btn-pause {
            width: 50px; height: 50px; border-radius: 50%; border: 2px solid #666;
            color: #fff; font-size: 20px; margin-left: 10px; background: #222;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
        }

        /* Upgrade Menu */
        #ui-layer { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; }

        #upg-menu {
            position: absolute; display: none; pointer-events: auto; z-index: 100;
            background: rgba(0,20,0,0.95); border: 1px solid #0f0; border-radius: 6px;
            padding: 6px; text-align: center; box-shadow: 0 0 20px rgba(0,255,0,0.3);
            width: 140px; /* Fixed width for calculation */
        }
        .menu-header { font-size:11px; color:#0f0; margin-bottom:6px; border-bottom: 1px solid #050; padding-bottom: 4px; }
        .menu-btn { 
            display: block; width: 100%; padding: 12px 0; margin: 4px 0; 
            background: #111; color: #fff; border: 1px solid #333; font: inherit; font-size: 12px; 
            cursor: pointer; touch-action: manipulation; border-radius: 3px;
        }
        .menu-btn:active { background: #333; transform: scale(0.98); }
        .btn-upg { color: #afa; border-color: #252; } 
        .btn-sell { color: #f55; border-color: #522; }
        .btn-lock { color: #0af; border-color: #058; display: none; }

        /* Next Wave Button */
        #btn-wave {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 8px 20px; border-radius: 20px; pointer-events: auto; cursor: pointer;
            font-size: 14px; animation: pulse 1s infinite; display: none;
            background: rgba(0, 40, 40, 0.9); border: 1px solid #3ff; color: #3ff;
        }
        @keyframes pulse { 0% {box-shadow:0 0 5px #3ff;} 50%{box-shadow:0 0 15px #3ff;} 100%{box-shadow:0 0 5px #3ff;} }

        /* Overlay */
        #overlay { 
            position: fixed; top:0;left:0;width:100%;height:100%; background:rgba(0,0,0,0.95); 
            color:#0f0; display:flex; flex-direction:column; align-items:center; justify-content:center; 
            font-size:20px; z-index:999; text-shadow: 0 0 20px #0f0; text-align: center;
        }
        .blink { animation: blinker 1s linear infinite; margin-top: 20px; font-size: 14px; color: #fff;}
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div id="top-bar">
    <div id="btn-fx" class="top-btn active">FX: ON</div>
    <div class="stat-group">
        <span class="stat-cash">$<span id="ui-cash">120</span></span>
        <span class="stat-score">SC <span id="ui-score">0</span></span>
        <span class="stat-wave">WV <span id="ui-wave">1</span></span>
    </div>
    <div id="btn-speed" class="top-btn">1x</div>
</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div id="btn-wave">NEXT WAVE (<span id="ui-timer">0</span>)</div>
        <div id="upg-menu">
            <div class="menu-header" id="m-info">TOWER</div>
            <button class="menu-btn btn-upg" id="m-upg">UPGRADE</button>
            <button class="menu-btn btn-lock" id="m-lock">LOCK ANGLE</button>
            <button class="menu-btn btn-sell" id="m-sell">SELL</button>
        </div>
    </div>
</div>

<div id="bottom-bar">
    <div class="tower-card" id="card-green" data-type="green" style="border-color:#050"><canvas class="t-canvas" id="icon-green"></canvas><span class="t-cost">$15</span></div>
    <div class="tower-card" id="card-blue" data-type="blue" style="border-color:#005"><canvas class="t-canvas" id="icon-blue"></canvas><span class="t-cost">$80</span></div>
    <div class="tower-card" id="card-red" data-type="red" style="border-color:#500"><canvas class="t-canvas" id="icon-red"></canvas><span class="t-cost">$40</span></div>
    <div class="tower-card" id="card-purple" data-type="purple" style="border-color:#505"><canvas class="t-canvas" id="icon-purple"></canvas><span class="t-cost">$120</span></div>
    <div class="tower-card" id="card-yellow" data-type="yellow" style="border-color:#550"><canvas class="t-canvas" id="icon-yellow"></canvas><span class="t-cost">$60</span></div>
    <div class="tower-card" id="card-orange" data-type="orange" style="border-color:#530"><canvas class="t-canvas" id="icon-orange"></canvas><span class="t-cost">$100</span></div>
    <div id="btn-pause">||</div>
</div>

<div id="overlay">
    <div>GEODEFENSE SWARM V2.13</div>
    <div style="font-size:12px; color:#aaa; margin-top:10px">Fix: Upgrade bugs & Off-screen menus.<br>Drag to build. Tap to upgrade.</div>
    <div class="blink">TAP TO START</div>
</div>

<script>
// --- Audio & Config ---
const TOWER_DATA = {
    green:  { name: "BLASTER", cost: 15, range: 90,  dmg: 8, rate: 12, color: '#0f0', type:'bolt' },
    blue:   { name: "LASER",   cost: 80, range: 130, dmg: 0.8,rate: 0,  color: '#0af', type:'laser' },
    red:    { name: "MISSILE", cost: 40, range: 140, dmg: 40, rate: 70, color: '#f00', type:'missile', splash: 50 },
    purple: { name: "SNIPER",  cost: 120,range: 300, dmg: 150,rate: 110,color: '#d0f', type:'sniper' },
    yellow: { name: "SHOCK",   cost: 60, range: 100, dmg: 0.5,rate: 5,  color: '#ff0', type:'shock' },
    orange: { name: "COLLECTOR",cost: 100,range: 80,  dmg: 0,  rate: 0,  color: '#f80', type:'buff' }
};

let G = {
    w:0, h:0, hexR:0, active:false, paused:false, speed:1, enableFX: true,
    hp:20, cash:120, wave:1, score:0,
    grid:[], path:[], towers:[], enemies:[], projs:[], parts:[], shocks:[],
    start:null, end:null, selected:null,
    dragType:null, dragPos:{x:0,y:0},
    nextWaveTime:0, spawning:false, spawnQ:0, frame:0, shake: 0
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const container = document.getElementById('game-container');
let actx;

// --- Helper: Touch Binding (The key to mobile success) ---
function bindTouch(id, fn) {
    const el = document.getElementById(id);
    if(el) {
        // Remove old listeners to prevent stacking if function called multiple times (though we only call init once)
        let newEl = el.cloneNode(true);
        el.parentNode.replaceChild(newEl, el);
        
        newEl.addEventListener('touchstart', (e) => { 
            e.preventDefault(); e.stopPropagation(); 
            fn(e); 
        }, {passive: false});
        
        // Mouse fallback
        newEl.addEventListener('click', (e) => { 
            e.preventDefault(); 
            fn(e); 
        });
    }
}

// --- System ---
function initAudio() { if(!actx) actx = new (window.AudioContext || window.webkitAudioContext)(); }
function playSound(type) {
    if(!actx || !G.enableFX) return;
    const osc = actx.createOscillator(); const gain = actx.createGain();
    osc.connect(gain); gain.connect(actx.destination); let t = actx.currentTime;
    if(type==='shoot') { osc.type='triangle'; osc.frequency.setValueAtTime(800,t); osc.frequency.exponentialRampToValueAtTime(100,t+0.1); gain.gain.setValueAtTime(0.05,t); gain.gain.exponentialRampToValueAtTime(0.01,t+0.1); osc.start(t); osc.stop(t+0.1); }
    else if(type==='boom') { osc.type='sawtooth'; osc.frequency.setValueAtTime(60,t); osc.frequency.exponentialRampToValueAtTime(10,t+0.4); gain.gain.setValueAtTime(0.3,t); gain.gain.exponentialRampToValueAtTime(0.01,t+0.4); osc.start(t); osc.stop(t+0.4); }
    else if(type==='place') { osc.type='sine'; osc.frequency.setValueAtTime(400,t); osc.frequency.linearRampToValueAtTime(800,t+0.15); gain.gain.setValueAtTime(0.2,t); gain.gain.linearRampToValueAtTime(0,t+0.15); osc.start(t); osc.stop(t+0.15); }
}

bindTouch('btn-pause', () => { G.paused = !G.paused; document.getElementById('btn-pause').innerText = G.paused ? "â–º" : "||"; });
bindTouch('btn-speed', () => { G.speed = G.speed===1 ? 2 : 1; document.getElementById('btn-speed').innerText = G.speed+"x"; });
bindTouch('btn-fx', () => { G.enableFX = !G.enableFX; let btn=document.getElementById('btn-fx'); btn.innerText="FX: "+(G.enableFX?"ON":"OFF"); btn.classList.toggle('active',G.enableFX); });
bindTouch('btn-wave', forceNextWave);
bindTouch('overlay', startGame);

function startGame() {
    initAudio(); document.getElementById('overlay').style.display='none';
    G.active=true; resize(); renderTowerIcons(); setTimer(5); 
    setupAllListeners();
    loop();
}

function setupAllListeners() {
    // Game Control Buttons

    // Tower Upgrade Buttons (Bound ONCE here to prevent multi-trigger bug)
    bindTouch('m-upg', () => {
        if(!G.selected) return;
        let t = G.selected; let isMax = t.lvl >= 6;
        let cost = Math.floor(t.cost * t.lvl * 0.7);
        if(!isMax && G.cash >= cost) {
            G.cash -= cost; t.lvl++; t.dmg *= 1.35; 
            playSound('place'); fxHalo(t.x,t.y,t.color); updateUI(); updateMenuUI();
        } else playSound('boom');
    });

    bindTouch('m-sell', () => {
        if(!G.selected) return;
        let t = G.selected; let sell = Math.floor(t.cost * 0.5 * t.lvl);
        G.cash += sell; 
        let cell = G.grid.find(g=>g.q===t.q && g.r===t.r);
        if(cell) cell.occ = false;
        G.towers = G.towers.filter(to => to !== t);
        calcPath(); updateUI(); closeMenu();
    });

    bindTouch('m-lock', () => {
        if(!G.selected || G.selected.type !== 'laser') return;
        G.selected.lockedAngle = (G.selected.lockedAngle !== null) ? null : G.selected.angle;
        updateMenuUI();
    });

    // Tower Cards Dragging
    ['green','blue','red','purple','yellow','orange'].forEach(type => {
        let el = document.getElementById('card-'+type);
        el.addEventListener('touchstart', e => startDrag(e, type), {passive:false});
        el.addEventListener('mousedown', e => startDrag(e, type));
    });

    // Canvas Interaction
    window.addEventListener('touchmove', moveDrag, {passive:false});
    window.addEventListener('mousemove', moveDrag);
    window.addEventListener('touchend', endDrag);
    window.addEventListener('mouseup', endDrag);
    
    // Canvas Click/Touch for selection
    canvas.addEventListener('touchstart', (e) => { 
        if(e.touches.length === 1) handleClick({clientX: e.touches[0].clientX, clientY: e.touches[0].clientY}); 
    }, {passive:false});
    canvas.addEventListener('click', handleClick);
}

function resize() {
    let rect = container.getBoundingClientRect();
    G.w = rect.width; G.h = rect.height;
    canvas.width = G.w; canvas.height = G.h;
    let minDim = Math.min(G.w, G.h);
    G.hexR = Math.max(14, Math.floor(minDim / 20)); 
    if(G.hexR > 35) G.hexR = 35;
    initGrid();
}

// ... (Map Gen & Path same as before) ...
function initGrid() {
    let validMap = false;
    while(!validMap) {
        G.grid = [];
        const w = G.hexR * Math.sqrt(3); const h = G.hexR * 2; const vDist = h * 0.75;
        const cols = Math.floor(G.w / w); const rows = Math.floor(G.h / vDist);
        const offX = (G.w - cols * w)/2 + w/2; const offY = (G.h - rows * vDist)/2 + h/2;
        let floorTiles = [];
        for(let r=0; r<rows; r++) {
            for(let q=0; q<cols; q++) {
                let cx = offX + q * w + (r%2 ? w/2 : 0); let cy = offY + r * vDist;
                if(cy < G.hexR*1.5 || cy > G.h - G.hexR*1.5) continue; 
                let isEdge = (cx < G.hexR*1.5 || cx > G.w - G.hexR*1.5 || cy < G.hexR*1.5 || cy > G.h - G.hexR*1.5);
                let isObstacle = isEdge || (Math.random() < 0.12);
                let cell = { q, r, x:cx, y:cy, occ: isObstacle, type: isObstacle ? 'obs' : 'floor', id: r*1000+q };
                G.grid.push(cell); if(!isObstacle) floorTiles.push(cell);
            }
        }
        let minD = G.w*0.5; let tries=0;
        do {
            G.start = floorTiles[Math.floor(Math.random()*floorTiles.length)];
            G.end = floorTiles[Math.floor(Math.random()*floorTiles.length)];
            tries++;
        } while(dist(G.start,G.end) < minD && tries<100);
        G.start.occ=false; G.start.type='floor'; G.end.occ=false; G.end.type='floor';
        getNeighbors(G.start).forEach(n=>{n.occ=false; n.type='floor';});
        getNeighbors(G.end).forEach(n=>{n.occ=false; n.type='floor';});
        if(calcPath()) validMap = true;
    }
}
function calcPath(tempBlock=null) {
    if(tempBlock) tempBlock.occ=true;
    let open=[G.start], cameFrom=new Map(), gScore=new Map();
    gScore.set(G.start, 0); let found=false;
    while(open.length>0) {
        open.sort((a,b)=>(gScore.get(a)+dist(a,G.end))-(gScore.get(b)+dist(b,G.end)));
        let cur=open.shift();
        if(cur===G.end){found=true; break;}
        for(let n of getNeighbors(cur)) {
            if(n.occ) continue;
            let g=gScore.get(cur)+1;
            if(g<(gScore.get(n)||Infinity)) { cameFrom.set(n,cur); gScore.set(n,g); if(!open.includes(n)) open.push(n); }
        }
    }
    if(tempBlock) tempBlock.occ=false;
    if(!found) return null;
    let path=[], curr=G.end;
    while(curr!==G.start) { path.push(curr); curr=cameFrom.get(curr); }
    path.push(G.start);
    return G.path=path.reverse();
}

// --- Logic ---
function loop() {
    requestAnimationFrame(loop);
    if(!G.active || G.paused) return;
    let loops = G.speed; while(loops--) { G.frame++; updateLogic(); }
    draw();
}

function updateLogic() {
    if(G.spawning) {
        let rate = Math.max(15, 35 - G.wave); 
        if(G.spawnQ>0 && G.frame%rate===0) { 
            spawnEnemy(); G.spawnQ--; 
            if(G.spawnQ<=0) { G.spawning=false; setTimer(10); } 
        }
    }
    if(G.nextWaveTime>0 && Date.now()>G.nextWaveTime) startWave();
    
    let tSpan=document.getElementById('ui-timer');
    if(G.nextWaveTime>0) {
        document.getElementById('btn-wave').style.display='flex';
        let left=Math.ceil((G.nextWaveTime-Date.now())/1000); tSpan.innerText = left>0?left:0;
    } else document.getElementById('btn-wave').style.display='none';

    G.towers.forEach(t => t.buffVal=1);
    G.towers.filter(t=>t.type==='buff').forEach(c => {
        G.towers.forEach(t => { if(t!==c && dist(c,t)<=c.range+10) t.buffVal = 1.25+(c.lvl*0.1); });
    });

    G.towers.forEach(t => {
        if(t.cd>0) t.cd--;
        let buff = t.buffVal || 1; let range = t.range * (1 + (t.lvl-1)*0.05);
        if(t.type === 'laser') {
            let hasTarget = false;
            if(t.lockedAngle != null) { t.angle = t.lockedAngle; hasTarget = G.enemies.some(e=>dist(t,e)<=range); } 
            else {
                t.target=null; let best=Infinity;
                G.enemies.forEach(e=>{ if(e.reached) return; let d=dist(t,e); if(d<range && d<best){ best=d; t.target=e;} });
                if(t.target) { t.angle=Math.atan2(t.target.y-t.y, t.target.x-t.x); hasTarget = true; }
            }
            if(hasTarget) fireLaser(t, buff);
        } else if(t.type === 'shock') {
            let maxTargets = 2 + t.lvl;
            t.targets = G.enemies.filter(e => dist(t,e) <= range && !e.reached).slice(0, maxTargets);
            t.targets.forEach(e => { if(G.frame%t.rate===0) { e.hp-=t.dmg*(1+t.lvl*0.5)*buff; e.slow=20; } });
        } else if(t.type !== 'buff') {
            if(!t.target || t.target.hp<=0 || dist(t,t.target)>range || t.target.reached) t.target = G.enemies.find(e => dist(t,e)<=range && !e.reached);
            if(t.target) {
                t.angle = Math.atan2(t.target.y-t.y, t.target.x-t.x);
                if(t.cd<=0) {
                    let dmg = t.dmg * Math.pow(1.4, t.lvl-1) * buff;
                    G.projs.push({ x:t.x, y:t.y, vx:Math.cos(t.angle), vy:Math.sin(t.angle), spd:10, dmg:dmg, color:t.color, type:t.type, splash:t.splash||0, tar:t.target, life:80 });
                    t.cd = t.rate/(1+(t.lvl-1)*0.15); if(G.enableFX) playSound('shoot');
                }
            }
        }
    });

    for(let i=G.projs.length-1; i>=0; i--) {
        let p=G.projs[i]; p.life--;
        if(p.type==='missile' && p.tar && p.tar.hp>0) { let ta=Math.atan2(p.tar.y-p.y, p.tar.x-p.x); p.vx=p.vx*0.92+Math.cos(ta)*0.08; p.vy=p.vy*0.92+Math.sin(ta)*0.08; }
        p.x+=p.vx*p.spd; p.y+=p.vy*p.spd; if(p.type==='frag') p.spd*=0.9;
        let hit = G.enemies.find(e => dist(p,e) < (p.type==='missile'?20:12));
        if(hit || p.life<=0) {
            if(hit || (p.type==='missile' && p.life<=0)) {
                if(p.type==='missile') {
                    if(G.enableFX) { playSound('boom'); fxExplode(p.x,p.y,p.color,12); G.shocks.push({x:p.x, y:p.y, r:1, maxR:60, color:p.color, alpha:1}); }
                    G.enemies.forEach(e=>{if(dist(p,e)<p.splash) e.hp-=p.dmg;});
                    for(let k=0;k<4;k++){ let a=Math.random()*6.28; G.projs.push({x:p.x,y:p.y,vx:Math.cos(a),vy:Math.sin(a),spd:6,dmg:p.dmg*0.3,color:'#fa0',type:'frag',life:20}); }
                } else { hit.hp-=p.dmg; if(G.enableFX) fx(p.x,p.y,p.color,3); }
            }
            if(hit||p.life<=0) G.projs.splice(i,1);
        }
    }

    for(let i=G.enemies.length-1; i>=0; i--) {
        let e=G.enemies[i];
        if(e.hp<=0) { 
            G.cash+=e.val; G.score+=e.val*10; 
            if(G.enableFX) { fxExplode(e.x,e.y,e.color,20); fxHalo(e.x,e.y,e.color); }
            updateUI(); G.enemies.splice(i,1); continue; 
        }
        let target = G.path[e.pi];
        if(dist(e, G.end) < G.hexR) {
            G.hp--; if(G.enableFX) fxExplode(e.x,e.y,'#f00',20); updateUI(); G.enemies.splice(i,1);
            if(G.hp<=0) { G.active=false; alert("GAME OVER! Score: "+G.score); location.reload(); } continue;
        }
        if(target) {
            let tx=target.x+e.ox, ty=target.y+e.oy;
            let moveSpd = e.spd * (e.slow>0 ? 0.4 : 1); if(e.slow>0) e.slow--;
            let dx=tx-e.x, dy=ty-e.y, d=Math.hypot(dx,dy);
            if(d<moveSpd) e.pi++; else { e.x+=dx/d*moveSpd; e.y+=dy/d*moveSpd; e.angle=Math.atan2(dy,dx); }
        } else { e.reached = true; G.hp--; updateUI(); G.enemies.splice(i,1); }
    }
    
    for(let i=G.shocks.length-1; i>=0; i--) { let s=G.shocks[i]; s.r+=2; s.alpha-=0.05; if(s.alpha<=0) G.shocks.splice(i,1); }
    for(let i=G.parts.length-1; i>=0; i--) { let p=G.parts[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.05; if(p.life<=0) G.parts.splice(i,1); }
}

function draw() {
    ctx.fillStyle = '#050505'; ctx.fillRect(0,0,G.w,G.h);
    ctx.lineWidth = 1;
    G.grid.forEach(c => {
        if(c.type === 'obs') {
            ctx.fillStyle = '#ccc'; ctx.strokeStyle='#999'; ctx.beginPath(); hexPath(c.x,c.y,G.hexR-1); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#999'; ctx.beginPath(); ctx.moveTo(c.x, c.y); ctx.arc(c.x, c.y, G.hexR-2, 0, Math.PI); ctx.fill();
        } else if(!c.occ) {
            ctx.strokeStyle = '#004444'; ctx.beginPath(); hexPath(c.x,c.y,G.hexR); ctx.stroke();
        }
    });
    drawHexSolid(G.start.x, G.start.y, G.hexR, '#0f0', 0.2); drawHexSolid(G.end.x, G.end.y, G.hexR, '#f00', 0.3);
    ctx.fillStyle = '#fff'; ctx.font = "bold 16px Courier New"; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(G.hp, G.end.x, G.end.y);

    if(G.enableFX) ctx.globalCompositeOperation = 'lighter';

    G.towers.forEach(t => {
        drawHexSolid(t.x, t.y, G.hexR, t.color, 0.1 + (t.lvl*0.05));
        ctx.strokeStyle = t.color; ctx.shadowColor = t.color; ctx.shadowBlur = G.enableFX ? 10 : 0;
        if(t.type === 'buff') {
            G.towers.forEach(target => { if(target !== t && dist(t,target) <= t.range+10) { ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(target.x,target.y); ctx.lineWidth=1; ctx.globalAlpha=0.4; ctx.stroke(); ctx.globalAlpha=1; } });
        }
        ctx.save(); ctx.translate(t.x,t.y);
        if(t.lvl > 1) { ctx.beginPath(); ctx.arc(0,0,G.hexR*0.6,0,6.28); ctx.stroke(); }
        if(t.lvl > 3) { ctx.beginPath(); ctx.arc(0,0,G.hexR*0.8,0,6.28); ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]); }
        if(t.lvl === 6) { ctx.beginPath(); ctx.arc(0,0,G.hexR*0.95,0,6.28); ctx.lineWidth=2; ctx.stroke(); ctx.lineWidth=1; }
        if(t.type !== 'buff') ctx.rotate(t.angle);
        let scale = G.hexR / 20; ctx.scale(scale, scale); drawTowerShape(ctx, t.type, t.lvl, t.color);
        ctx.restore();
        if(t.type==='laser' && t.firing) { ctx.shadowBlur=G.enableFX?15:0; ctx.lineWidth=2+(t.lvl*0.5); ctx.strokeStyle=t.color; ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(t.x+Math.cos(t.angle)*2000, t.y+Math.sin(t.angle)*2000); ctx.stroke(); ctx.lineWidth=1; t.firing=false; }
        if(t.type==='shock' && t.targets) { ctx.strokeStyle=t.color; ctx.lineWidth=2; t.targets.forEach(e => { ctx.beginPath(); ctx.moveTo(t.x,t.y); let mx = (t.x+e.x)/2 + (Math.random()-0.5)*20; let my = (t.y+e.y)/2 + (Math.random()-0.5)*20; ctx.lineTo(mx, my); ctx.lineTo(e.x, e.y); ctx.stroke(); }); }
    });

    G.enemies.forEach(e => {
        ctx.fillStyle = e.color; ctx.shadowColor = e.color; ctx.shadowBlur = G.enableFX ? 10 : 0; ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5;
        ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle);
        ctx.beginPath(); let s = e.size || 8;
        if(e.shape==='circle') ctx.arc(0,0,s,0,6.28);
        else if(e.shape==='triangle') { ctx.moveTo(s,0); ctx.lineTo(-s, s); ctx.lineTo(-s, -s); ctx.closePath(); }
        else if(e.shape==='square') { ctx.rect(-s,-s, s*2, s*2); }
        else if(e.shape==='pentagon') { for(let i=0;i<5;i++) ctx.lineTo(s*Math.cos(i*1.25), s*Math.sin(i*1.25)); ctx.closePath(); }
        ctx.fill(); ctx.stroke(); ctx.rotate(-e.angle); 
        ctx.fillStyle='#000'; ctx.fillRect(-5, -8, 10, 2); ctx.fillStyle='#0f0'; ctx.fillRect(-5, -8, 10*(Math.max(0,e.hp)/e.max), 2);
        ctx.restore();
    });

    G.projs.forEach(p => { ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y, p.type==='frag'?2:3, 0, 6.28); ctx.fill(); });
    if(G.enableFX) { G.shocks.forEach(s => { ctx.strokeStyle=s.color; ctx.globalAlpha=s.alpha; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,6.28); ctx.stroke(); ctx.globalAlpha=1; }); G.parts.forEach(p => { ctx.globalAlpha=p.life; ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,2,2); ctx.globalAlpha=1; }); }

    if(G.dragType) {
        let ghostY = G.dragPos.y - 80; let hex = pixelToHex(G.dragPos.x, ghostY); let data = TOWER_DATA[G.dragType];
        ctx.strokeStyle = data.color; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.arc(G.dragPos.x, ghostY, data.range, 0, 6.28); ctx.stroke(); ctx.setLineDash([]);
        ctx.save(); ctx.translate(G.dragPos.x, ghostY); let scale = G.hexR / 20; ctx.scale(scale, scale); drawTowerShape(ctx, data.type, 1, data.color); ctx.restore();
        if(hex) drawHexSolid(hex.x, hex.y, G.hexR, data.color, 0.5);
    }
    if(G.selected) { ctx.strokeStyle='#fff'; ctx.setLineDash([5,5]); ctx.beginPath(); ctx.arc(G.selected.x, G.selected.y, G.selected.range * (1 + (G.selected.lvl-1)*0.05), 0, 6.28); ctx.stroke(); ctx.setLineDash([]); }
    
    ctx.restore(); ctx.globalCompositeOperation = 'source-over'; ctx.shadowBlur=0;
}

// --- Interaction ---
function startDrag(e, type) { e.preventDefault(); if(G.selected) closeMenu(); G.dragType = type; updateDragPos(e); }
function moveDrag(e) { if(G.dragType) { e.preventDefault(); updateDragPos(e); } }
function updateDragPos(e) { let t = e.touches?e.touches[0]:e; let r = canvas.getBoundingClientRect(); G.dragPos.x = t.clientX - r.left; G.dragPos.y = t.clientY - r.top; }
function endDrag(e) {
    e.preventDefault(); if(!G.dragType) return;
    let hex = pixelToHex(G.dragPos.x, G.dragPos.y - 80); let data = TOWER_DATA[G.dragType];
    if(hex && !hex.occ && hex.type!=='obs' && hex!==G.start && hex!==G.end) {
        if(G.cash >= data.cost) {
            if(calcPath(hex)) {
                G.cash -= data.cost; hex.occ = true; G.towers.push({q:hex.q, r:hex.r, x:hex.x, y:hex.y, ...data, cd:0, lvl:1, angle:0});
                playSound('place'); fxExplode(hex.x, hex.y, '#fff', 8); updateUI();
            } else { playSound('boom'); fxExplode(hex.x,hex.y,'#f00',5); }
        } else playSound('boom');
    }
    G.dragType = null;
}
function handleClick(e) {
    if(G.dragType) return;
    let r = canvas.getBoundingClientRect();
    let hex = pixelToHex(e.clientX - r.left, e.clientY - r.top);
    if(hex && hex.occ && hex.type!=='obs') { let t = G.towers.find(to => to.q === hex.q && to.r === hex.r); if(t) selectTower(t); } else closeMenu();
}
function selectTower(t) {
    G.selected = t;
    const m = document.getElementById('upg-menu'); 
    let menuW = 120, menuH = 100;
    // Smart Positioning
    let mx = t.x - menuW/2;
    let my = t.y - G.hexR - menuH;
    if(my < 10) my = t.y + G.hexR + 10; // Flip down if too high
    if(mx < 10) mx = 10; // Clamp left
    if(mx > G.w - menuW - 10) mx = G.w - menuW - 10; // Clamp right
    
    m.style.display = 'block'; m.style.left = mx+'px'; m.style.top = my+'px';
    updateMenuUI();
}
function updateMenuUI() {
    if(!G.selected) return; let t = G.selected;
    let isMax = t.lvl >= 6; let cost = Math.floor(t.cost * t.lvl * 0.7); let sell = Math.floor(t.cost * 0.5 * t.lvl);
    document.getElementById('m-info').innerText = `${t.name} LVL ${t.lvl}`;
    let btnUp = document.getElementById('m-upg');
    btnUp.innerText = isMax ? "MAX" : `UPGRADE $${cost}`; btnUp.style.opacity = (isMax || G.cash < cost) ? 0.5 : 1;
    document.getElementById('m-sell').innerText = `SELL $${sell}`;
    let btnLock = document.getElementById('m-lock');
    if(t.type === 'laser') { btnLock.style.display = 'block'; btnLock.innerText = (t.lockedAngle != null) ? "UNLOCK" : "LOCK"; } else btnLock.style.display = 'none';
}
function closeMenu() { G.selected=null; document.getElementById('upg-menu').style.display='none'; }
function updateUI() { document.getElementById('ui-cash').innerText = Math.floor(G.cash); document.getElementById('ui-wave').innerText = G.wave; document.getElementById('ui-score').innerText = G.score; }
function renderTowerIcons() { for(let key in TOWER_DATA) { let cvs = document.getElementById('icon-'+key); if(cvs) { cvs.width=48; cvs.height=40; let cx = cvs.getContext('2d'); cx.translate(24, 25); cx.scale(0.8, 0.8); let data = TOWER_DATA[key]; cx.save(); drawTowerShape(cx, data.type, 1, data.color); cx.restore(); } } }
function setTimer(s) { G.nextWaveTime = Date.now() + s*1000; }
function forceNextWave() { if(G.nextWaveTime > Date.now()) G.score += Math.ceil((G.nextWaveTime - Date.now())/1000)*50; startWave(); }
function startWave() { G.wave++; G.spawnQ = 6+Math.floor(G.wave*1.5); G.spawning=true; G.nextWaveTime=0; updateUI(); }
function spawnEnemy() {
    let stage = Math.floor((G.wave-1)/5); let baseHp = 20 + (G.wave*5);
    if(stage>=1) baseHp*=1.5; if(stage>=2) baseHp*=2.0;
    let shape='circle', spd=1.0+(G.wave*0.03);
    if(G.wave%5===0) { shape='pentagon'; baseHp*=4; spd*=0.5; }
    else if(stage>=1 && Math.random()>0.7) { shape='triangle'; baseHp*=0.6; spd*=1.5; }
    else if(stage>=2 && Math.random()>0.7) { shape='square'; baseHp*=3.0; spd*=0.6; }
    let e = { x:G.start.x, y:G.start.y, pi:0, slow:0, hp:baseHp, max:baseHp, spd:spd, val: 5+Math.floor(G.wave/2), shape: shape, color: `hsl(${(G.wave*25)%360},100%,60%)`, angle: 0, ox: (Math.random()-0.5)*(G.hexR*0.8), oy: (Math.random()-0.5)*(G.hexR*0.8), reached:false };
    G.enemies.push(e);
}
function fireLaser(t, buff) {
    let ex = t.x+Math.cos(t.angle)*2000, ey = t.y+Math.sin(t.angle)*2000; t.firing=true;
    G.enemies.forEach(e=>{ if(distToSegment({x:t.x,y:t.y}, {x:ex,y:ey}, e) < (e.size||10)) { e.hp -= t.dmg*(1+t.lvl*0.5)*buff; if(G.enableFX && G.frame%5===0) fx(e.x,e.y,t.color,1); } });
}
function hexPath(x,y,r) { for(let i=0;i<6;i++) { let a=Math.PI/3*i - Math.PI/6; i===0?ctx.moveTo(x+r*Math.cos(a),y+r*Math.sin(a)):ctx.lineTo(x+r*Math.cos(a),y+r*Math.sin(a)); } ctx.closePath(); }
function drawHexSolid(x,y,r,c,a=1) { ctx.fillStyle=c; ctx.globalAlpha=a; ctx.beginPath(); hexPath(x,y,r); ctx.fill(); ctx.globalAlpha=1; }
function pixelToHex(x, y) { let minD=Infinity, closest=null; for(let c of G.grid) { let d = Math.hypot(c.x-x, c.y-y); if(d < minD) { minD=d; closest=c; } } return (minD < G.hexR*1.5) ? closest : null; }
function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
function distToSegment(A, B, P) { const l2 = (A.x-B.x)**2 + (A.y-B.y)**2; if(l2==0) return dist(P,A); let t = ((P.x-A.x)*(B.x-A.x) + (P.y-A.y)*(B.y-A.y)) / l2; t = Math.max(0, Math.min(1, t)); return dist(P, { x: A.x + t*(B.x-A.x), y: A.y + t*(B.y-A.y) }); }
function fx(x,y,c,n) { if(!G.enableFX) return; for(let i=0;i<n;i++) G.parts.push({x,y,vx:(Math.random()-.5)*4,vy:(Math.random()-.5)*4,life:1,color:c}); }
function fxExplode(x,y,c,n) { fx(x,y,c,n*3); }
function fxHalo(x,y,c) { if(!G.enableFX) return; G.parts.push({x,y,r:5,life:1,color:c,type:'halo'}); }
function getNeighbors(c) { return G.grid.filter(n => dist(c,n) < G.hexR*2.1 && n!==c); }
function drawTowerShape(ctx, type, lvl, color) { ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath(); if(type === 'bolt') { ctx.rect(-5,-5,10,10); ctx.moveTo(5,0); ctx.lineTo(15+(lvl*2),0); if(lvl>=3) { ctx.moveTo(5,-3); ctx.lineTo(12,-3); ctx.moveTo(5,3); ctx.lineTo(12,3); } } else if (type === 'missile') { ctx.moveTo(-8,-8); ctx.lineTo(4,-4); ctx.lineTo(4,4); ctx.lineTo(-8,8); ctx.closePath(); ctx.rect(-6, -10, 4, 20); } else if (type === 'laser') { ctx.arc(0,0,5,0,6.28); ctx.moveTo(5,0); ctx.lineTo(10,0); ctx.arc(10,0,2,0,6.28); if(lvl>=4) { ctx.moveTo(10,-5); ctx.lineTo(15,0); ctx.lineTo(10,5); } } else if (type === 'shock') { ctx.moveTo(0,-8); ctx.lineTo(4,-2); ctx.lineTo(-4,2); ctx.lineTo(0,8); ctx.arc(0,0,8,0,6.28); } else if (type === 'sniper') { ctx.rect(-10,-3, 20, 6); ctx.moveTo(10,0); ctx.lineTo(30+(lvl*4), 0); ctx.rect(30+(lvl*4), -2, 4, 4); } else if (type === 'buff') { ctx.arc(0,0,4,0,6.28); ctx.moveTo(0,0); ctx.lineTo(8, -8); ctx.arc(8,-8, 3, 0, 6.28); } ctx.stroke(); }
</script>
</body>
</html>
